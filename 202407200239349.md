
### 顺序表

1. 顺序表的存储结构是顺序存储的。
2. 顺序表的插入操作时间复杂度是O(1)。
3. 顺序表的删除操作时间复杂度与链表相同，都是O(1)。
4. 顺序表在插入和删除操作时，可能需要移动大量元素。
5. 顺序表的查找操作时间复杂度为O(n)。
6. 顺序表的物理地址是连续的。

### 链表

7. 链表的每个节点都包含数据域和指针域。
8. 单向链表只能从头到尾单向遍历。
9. 双向链表可以从头到尾和从尾到头双向遍历。
10. 循环链表的最后一个节点指向链表的头节点。
11. 链表在插入和删除操作时，不需要移动大量元素。
12. 链表的查找操作时间复杂度为O(1)。
13. 链表的存储空间利用率比顺序表高。

### 栈和队列

14. 栈是先进先出(FIFO)的数据结构。
15. 队列是先进后出(LIFO)的数据结构。
16. 栈的插入和删除操作时间复杂度均为O(1)。
17. 队列的插入和删除操作时间复杂度均为O(1)。
18. 队列有顺序队列和链式队列两种存储方式。
19. 在顺序队列中，当队尾指针到达数组末尾时，队列已满。
20. 栈可以用数组实现，也可以用链表实现。
21. 队列可以用数组实现，也可以用链表实现。
22. 栈和队列的存储方式决定了它们的操作方式。

### 哈希表

23. 哈希表是一种线性表的存储结构。
24. 哈希表通过哈希函数将关键字映射到表中的位置。
25. 哈希表的查找效率与数据的规模无关。
26. 哈希表的冲突解决方法有链地址法和开放地址法。
27. 在最坏情况下，哈希表的查找时间复杂度为O(n)。
28. 哈希表的装载因子影响哈希表的性能。
29. 哈希表适合用于动态插入和删除的情况。
30. 哈希表的关键字分布越均匀，查找效率越高。


## 判断题

![image.png](https://cdn.jsdelivr.net/gh/oukoukouk/blog-img/202407200158626.png)


## 代码题


1. 在下面的代码注释部分填写代码，用快慢指针实现链表反转，只需简单的指针变换即可。

 **期望输出:\[5,4,3,2,1,0\]**
 
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Node
{
    int val;
    Node * nx;
};
int main()
{
    Node * head = new Node{0, nullptr}, *add = head; 
    vector<int> v{1, 2, 3, 4, 5};
    for (int i : v)
    {
        add->nx = new Node{i, nullptr};
        add = add->nx;
    }
    Node *fast = head, *slow = nullptr;
    while (fast)
    {
        /*
        在此处填写代码
        */
    }
    Node * res = slow;
    while (res)
    {
        cout << res->val << " ";
        res = res->nx;
    }
}
```

2. 假设在一个足够长的循环链表中
	1. 我们只有**倒数第二个节点**的指针，能否做到O(1)时间，删除**倒数第二**个节点？ 如果能，说出你的方法。
	2. 我们只有**倒数第一个节点**的指针，能否做到O(1)时间，删除**倒数第二**个节点？ 如果能，说出你的方法。
	3. 我们只有**倒数第一个节点**的指针，能否做到O(1)时间，删除**倒数第一**个节点？ 如果能，说出你的方法。